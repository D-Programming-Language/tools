/**
Functionality to generate code for the --eval and --loop flags
*/
module rdmd.eval;

import std.typecons : Flag;

// For --eval and --loop
private immutable string importWorld = "
module temporary;
import std.stdio, std.algorithm, std.array, std.ascii, std.base64,
    std.bigint, std.bitmanip,
    std.compiler, std.complex, std.concurrency, std.container, std.conv,
    std.csv,
    std.datetime, std.demangle, std.digest.md, std.encoding, std.exception,
    std.file,
    std.format, std.functional, std.getopt, std.json,
    std.math, std.mathspecial, std.mmfile,
    std.numeric, std.outbuffer, std.parallelism, std.path, std.process,
    std.random, std.range, std.regex, std.signals, std.socket,
    std.stdint, std.stdio,
    std.string, std.windows.syserror, std.system, std.traits, std.typecons,
    std.typetuple, std.uni, std.uri, std.utf, std.variant, std.xml, std.zip,
    std.zlib;
";

/**
Joins together the code provided via an `--eval` or `--loop`
flag, ensuring a trailing `;` is added if not already provided
by the user

Params:
    eval = array of strings generated by the `--eval`
           or `--loop` rdmd flags

Returns:
    string of code to be evaluated, corresponding to the
    inner code of either the program or the loop
*/
private string innerEvalCode(string[] eval)
{
    import std.string : join, stripRight;
    // assumeSafeAppend just to avoid unnecessary reallocation
    string code = eval.join("\n").stripRight.assumeSafeAppend;
    if (code.length > 0 && code[$ - 1] != ';')
        code ~= ';';
    return code;
}

unittest
{
    assert(innerEvalCode([`writeln("Hello!")`]) == `writeln("Hello!");`);
    assert(innerEvalCode([`writeln("Hello!");`]) == `writeln("Hello!");`);

    // test with trailing whitespace
    assert(innerEvalCode([`writeln("Hello!")  `]) == `writeln("Hello!");`);
    assert(innerEvalCode([`writeln("Hello!");  `]) == `writeln("Hello!");`);

    // test with multiple entries
    assert(innerEvalCode([`writeln("Hello!");  `, `writeln("You!")  `])
           == "writeln(\"Hello!\");  \nwriteln(\"You!\");");
    assert(innerEvalCode([`writeln("Hello!");  `, `writeln("You!"); `])
           == "writeln(\"Hello!\");  \nwriteln(\"You!\");");
}

/**
Formats the code provided via `--eval` or `--loop` flags into a
string of complete program code that can be written to a file
and then compiled

Params:
    eval = array of strings generated by the `--eval` or
           `--loop` rdmd flags
    loop = set to `Yes.loop` if this code comes from a
           `--loop` flag, `No.loop` if it comes from an
           `--eval` flag

Returns:
    string of code to be evaluated, corresponding to the
    inner code of either the program or the loop
*/
string makeEvalCode(string[] eval, Flag!"loop" loop)
{
    import std.format : format;
    immutable codeFormat = importWorld
        ~ "void main(char[][] args) {%s%s\n%s}";

    immutable innerCodeOpening =
        loop ? " foreach (line; std.stdio.stdin.byLine()) {\n"
             : "\n";

    immutable innerCodeClosing = loop ? "} " : "";

    return format(codeFormat,
                  innerCodeOpening,
                  innerEvalCode(eval),
                  innerCodeClosing);
}

unittest
{
    import std.typecons : No, Yes;

    // innerEvalCode already tests the cases for different
    // contents in `eval` array, so let's focus on testing
    // the difference based on the `loop` flag
    assert(makeEvalCode([`writeln("Hello!") `], No.loop) ==
           importWorld
           ~ "void main(char[][] args) {\n"
           ~ "writeln(\"Hello!\");\n}");

    assert(makeEvalCode([`writeln("What!"); `], No.loop) ==
           importWorld
           ~ "void main(char[][] args) {\n"
           ~ "writeln(\"What!\");\n}");

    assert(makeEvalCode([`writeln("Loop!") ; `], Yes.loop) ==
           importWorld
           ~ "void main(char[][] args) { "
           ~ "foreach (line; std.stdio.stdin.byLine()) {\n"
           ~ "writeln(\"Loop!\") ;\n} }");
}
